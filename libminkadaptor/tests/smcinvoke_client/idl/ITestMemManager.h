// Copyright (c) 2025, Qualcomm Innovation Center, Inc. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause

#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"

#define ITestMemManager_TEST_PATTERN1 UINT64_C(0xFEEDC0DEFACE0001)
#define ITestMemManager_TEST_PATTERN2 UINT64_C(0xFEEDC0DEFACE0002)

#define ITestMemManager_OP_access 0
#define ITestMemManager_OP_failRead 1
#define ITestMemManager_OP_failWrite 2
#define ITestMemManager_OP_failRelease 3
#define ITestMemManager_OP_fail64Bit 4
#define ITestMemManager_OP_failOverlap 5
#define ITestMemManager_OP_accessTwoMemObjects 6
#define ITestMemManager_OP_releaseImmediately 7

static inline int32_t
ITestMemManager_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ITestMemManager_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
ITestMemManager_access(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_access, a, ObjectCounts_pack(0, 0, 1, 0));
}

static inline int32_t
ITestMemManager_failRead(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_failRead, a, ObjectCounts_pack(0, 0, 1, 0));
}

static inline int32_t
ITestMemManager_failWrite(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_failWrite, a, ObjectCounts_pack(0, 0, 1, 0));
}

static inline int32_t
ITestMemManager_failRelease(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_failRelease, a, ObjectCounts_pack(0, 0, 1, 0));
}

static inline int32_t
ITestMemManager_fail64Bit(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_fail64Bit, a, ObjectCounts_pack(0, 0, 1, 0));
}

static inline int32_t
ITestMemManager_failOverlap(Object self, Object mo1_val, Object mo2_val)
{
  ObjectArg a[2]={{{0,0}}};
  a[0].o = mo1_val;
  a[1].o = mo2_val;

  return Object_invoke(self, ITestMemManager_OP_failOverlap, a, ObjectCounts_pack(0, 0, 2, 0));
}

static inline int32_t
ITestMemManager_accessTwoMemObjects(Object self, Object mo1_val, Object mo2_val)
{
  ObjectArg a[2]={{{0,0}}};
  a[0].o = mo1_val;
  a[1].o = mo2_val;

  return Object_invoke(self, ITestMemManager_OP_accessTwoMemObjects, a, ObjectCounts_pack(0, 0, 2, 0));
}

static inline int32_t
ITestMemManager_releaseImmediately(Object self, Object mo_val)
{
  ObjectArg a[1]={{{0,0}}};
  a[0].o = mo_val;

  return Object_invoke(self, ITestMemManager_OP_releaseImmediately, a, ObjectCounts_pack(0, 0, 1, 0));
}



