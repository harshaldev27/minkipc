// Copyright (c) 2025, Qualcomm Innovation Center, Inc. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause

/**
 * IDiagnostics is an interface enabling clients to obtain
 * diagnostic information.
 */
/** @cond */
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"

typedef struct {
  uint32_t totalSize;
  uint32_t usedSize;
  uint32_t freeSize;
  uint32_t overheadSize;
  uint32_t wastedSize;
  uint32_t largestFreeBlockSize;
} IDiagnostics_HeapInfo;

typedef struct {
  uint64_t totalSize;
  uint64_t totalFree;
  uint64_t largestContigFree;
} IDiagnostics_AppRegionInfo;

typedef struct {
  uint32_t appStatus;
  uint32_t userStackSize;
  uint32_t elStackSize;
  uint32_t acceptBufSize;
  uint64_t physMemorySize;
} IDiagnostics_AppInfo;

typedef struct {
  uint64_t regs[31];
  uint64_t sp;
  uint64_t cpsr;
  uint64_t pc;
  uint64_t es_reg;
  uint64_t fa_reg;
  uint64_t apibkeyhi;
  uint64_t apibkeylo;
  uint64_t reserved[4];
} IDiagnostics_RegisterInfo;



#define IDiagnostics_APP_STATUS_IDLE UINT32_C(1)
#define IDiagnostics_APP_STATUS_ABORT UINT32_C(2)
#define IDiagnostics_APP_STATUS_BLOCKED UINT32_C(3)

#define IDiagnostics_ERROR_APP_NOT_FOUND INT32_C(10)
#define IDiagnostics_ERROR_ARCH_NOT_SUPPORTED INT32_C(11)
#define IDiagnostics_ERROR_RESTRICTED INT32_C(12)

#define IDiagnostics_OP_queryHeapInfo 0
#define IDiagnostics_OP_queryLoadedApps 1
#define IDiagnostics_OP_queryAppRegion 2
#define IDiagnostics_OP_queryAppInfo 3
#define IDiagnostics_OP_queryAppDump 4

static inline int32_t
IDiagnostics_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IDiagnostics_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}

/*
*
*   Provides the caller with information regarding heap usage in QTEE.
*
*   @param[out] heapInfo  An output structure populated with heap
*                         usage information.
*
*   @return
*   Object_OK on success.
*
*/
static inline int32_t IDiagnostics_queryHeapInfo(Object self, IDiagnostics_HeapInfo *heapInfo_ptr)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) {  heapInfo_ptr, sizeof(IDiagnostics_HeapInfo) } },
    };

    int32_t result = Object_invoke(self, IDiagnostics_OP_queryHeapInfo, a, ObjectCounts_pack(0, 1, 0, 0));

    return result;
}

/*
*
*   Provides the caller with a list of the currently loaded
*   trusted applications.
*
*   @param[out] loadedApps  An output buffer populated with the distinguished
*                           name of every currently loaded app.
*                           Each entry in the list is separated by a single
*                           newline character.  A null-character is appended
*                           at the end of the list.
*                           The list has no guaranteed order.
*                           The caller must provide a buffer large enough
*                           for the entire output.
*
*   @return
*   Object_OK on success.
*   Object_ERROR_SIZE_OUT if the output buffer is not sufficiently large.
*
*/
static inline int32_t IDiagnostics_queryLoadedApps(Object self, void *loadedApps_ptr, size_t loadedApps_len, size_t *loadedApps_lenout)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { loadedApps_ptr, loadedApps_len * sizeof(uint8_t) } },
    };

    int32_t result = Object_invoke(self, IDiagnostics_OP_queryLoadedApps, a, ObjectCounts_pack(0, 1, 0, 0));
    *loadedApps_lenout = a[0].b.size / sizeof(uint8_t);

    return result;
}

/*
*
*   Returns the amount of available space (PIMEM and DDR) in the App Region.
*   Also returns the size of the largest contiguous space in PIMEM and DDR
*   and if Scattered Memory Allocation is supported.
*
*   @param[out] pimemInfo                   An output structure populated with PIMEM
*                                           usage information.
*   @param[out] ddrInfo                     An output structure populated with DDR
*                                           usage information.
*   @param[out] scatteredAllocatorSupport   Value of 1 if scattered Memory
*                                           Allocation is supported, 0 if it is not.
*
*   @return
*   Object_OK on success.
*
*/
static inline int32_t IDiagnostics_queryAppRegion(Object self, IDiagnostics_AppRegionInfo *pimemInfo_ptr, IDiagnostics_AppRegionInfo *ddrInfo_ptr, uint32_t *scatteredAllocatorSupport_ptr)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) {  pimemInfo_ptr, sizeof(IDiagnostics_AppRegionInfo) } },
        {.b = (ObjectBuf) {  ddrInfo_ptr, sizeof(IDiagnostics_AppRegionInfo) } },
        {.b = (ObjectBuf) { scatteredAllocatorSupport_ptr, sizeof(uint32_t) } },
    };

    int32_t result = Object_invoke(self, IDiagnostics_OP_queryAppRegion, a, ObjectCounts_pack(0, 3, 0, 0));

    return result;
}

/*
*
*   Provides the caller with information about the specified trusted application.
*
*   @param[in]  appDistName   Trusted application distinguished name.
*   @param[out] appInfo       An output structure populated with application runtime information.
*
*   @return
*   Object_OK - Successful. \n
*   Object_ERROR - Internal error retrieving application info. \n
*   IDiagnostics_ERROR_APP_NOT_FOUND - No loaded application with provided distinguished name. \n
*   IDiagnostics_ERROR_RESTRICTED - if debug is disabled.
*
*/
static inline int32_t IDiagnostics_queryAppInfo(Object self, const void *appDistName_ptr, size_t appDistName_len, IDiagnostics_AppInfo *appInfo_ptr)
{
    ObjectArg a[] = {
        {.bi = (ObjectBufIn) { appDistName_ptr, appDistName_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) {  appInfo_ptr, sizeof(IDiagnostics_AppInfo) } },
    };

    int32_t result = Object_invoke(self, IDiagnostics_OP_queryAppInfo, a, ObjectCounts_pack(1, 1, 0, 0));

    return result;
}

/*
*
*   Provides context information and stack content for specific loaded trusted application.
*
*   This API works only when debug is enabled.
*
*   @param[in]  distName     distinguished trusted application name to dump information
*   @param[out] usrRegInfo   Register values for user mode context
*   @param[out] usrStack     User mode stack content buffer
*   @param[out] usrStackAddr Start address of user mode stack
*
*   @return
*   Object_OK - on success. \n
*   Object_ERROR - Internal error retrieving application info. \n
*   Object_ERROR_SIZE_OUT - if provided buffer is too small for dumping stacks of given trusted application. \n
*   IDiagnostics_ERROR_ARCH_NOT_SUPPORTED - if archtecture type of given trusted application isn't supported. \n
*   IDiagnostics_ERROR_APP_NOT_FOUND - if trusted application with the distinguished name not found. \n
*   IDiagnostics_ERROR_RESTRICTED - if debug is disabled.
*
* 
*/
static inline int32_t IDiagnostics_queryAppDump(Object self, const void *distName_ptr, size_t distName_len, IDiagnostics_RegisterInfo *usrRegInfo_ptr, void *usrStack_ptr, size_t usrStack_len, size_t *usrStack_lenout, uint64_t *usrStackAddr_ptr)
{
    ObjectArg a[] = {
        {.bi = (ObjectBufIn) { distName_ptr, distName_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) {  usrRegInfo_ptr, sizeof(IDiagnostics_RegisterInfo) } },
        {.b = (ObjectBuf) { usrStack_ptr, usrStack_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) { usrStackAddr_ptr, sizeof(uint64_t) } },
    };
        
    int32_t result = Object_invoke(self, IDiagnostics_OP_queryAppDump, a, ObjectCounts_pack(1, 3, 0, 0));
    *usrStack_lenout = a[2].b.size / sizeof(uint8_t);
        
    return result;
}

